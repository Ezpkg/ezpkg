//go:build !genz

// Code generated by genz codez-matchers. DO NOT EDIT.

package codez

import (
	ast "go/ast"
	token "go/token"
)

// Comment
type CommentMatcherB struct {
	_ *ast.Comment

	Slash token.Pos
	Text  StringMatcher
}

func (m CommentMatcherB) MatchNode(cx *MatchContext, node ast.Node) (ok bool, err error) {
	return m.Match(cx, node)
}
func (m CommentMatcherB) Match(cx *MatchContext, node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.Comment)
	if !ok {
		return false, nil
	}
	ok, err = matchValue(cx, ok, err, m.Text, x.Text)
	return ok, err
}

// CommentGroup
type CommentGroupMatcherB struct {
	_ *ast.CommentGroup

	List ListMatcher[*ast.Comment]
}

func (m CommentGroupMatcherB) MatchNode(cx *MatchContext, node ast.Node) (ok bool, err error) {
	return m.Match(cx, node)
}
func (m CommentGroupMatcherB) Match(cx *MatchContext, node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.CommentGroup)
	if !ok {
		return false, nil
	}
	ok, err = matchList(cx, ok, err, m.List, x.List)
	return ok, err
}

// Field
type FieldMatcherB struct {
	_ *ast.Field

	Doc     CommentGroupMatcher
	Names   ListMatcher[*ast.Ident]
	Type    ExprMatcher
	Tag     BasicLitMatcher
	Comment CommentGroupMatcher
}

func (m FieldMatcherB) MatchNode(cx *MatchContext, node ast.Node) (ok bool, err error) {
	return m.Match(cx, node)
}
func (m FieldMatcherB) Match(cx *MatchContext, node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.Field)
	if !ok {
		return false, nil
	}
	ok, err = match(cx, ok, err, m.Doc, x.Doc)
	ok, err = matchList(cx, ok, err, m.Names, x.Names)
	ok, err = match(cx, ok, err, m.Type, x.Type)
	ok, err = match(cx, ok, err, m.Tag, x.Tag)
	ok, err = match(cx, ok, err, m.Comment, x.Comment)
	return ok, err
}

// FieldList
type FieldListMatcherB struct {
	_ *ast.FieldList

	Opening token.Pos
	List    ListMatcher[*ast.Field]
	Closing token.Pos
}

func (m FieldListMatcherB) MatchNode(cx *MatchContext, node ast.Node) (ok bool, err error) {
	return m.Match(cx, node)
}
func (m FieldListMatcherB) Match(cx *MatchContext, node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.FieldList)
	if !ok {
		return false, nil
	}
	ok, err = matchList(cx, ok, err, m.List, x.List)
	return ok, err
}

// File
type FileMatcherB struct {
	_ *ast.File

	Doc        CommentGroupMatcher
	Package    token.Pos
	Name       IdentMatcher
	Decls      ListMatcher[ast.Decl]
	FileStart  token.Pos
	FileEnd    token.Pos
	Imports    ListMatcher[*ast.ImportSpec]
	Unresolved ListMatcher[*ast.Ident]
	Comments   ListMatcher[*ast.CommentGroup]
	GoVersion  StringMatcher
}

func (m FileMatcherB) MatchNode(cx *MatchContext, node ast.Node) (ok bool, err error) {
	return m.Match(cx, node)
}
func (m FileMatcherB) Match(cx *MatchContext, node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.File)
	if !ok {
		return false, nil
	}
	ok, err = match(cx, ok, err, m.Doc, x.Doc)
	ok, err = match(cx, ok, err, m.Name, x.Name)
	ok, err = matchList(cx, ok, err, m.Decls, x.Decls)
	ok, err = matchList(cx, ok, err, m.Imports, x.Imports)
	ok, err = matchList(cx, ok, err, m.Unresolved, x.Unresolved)
	ok, err = matchList(cx, ok, err, m.Comments, x.Comments)
	ok, err = matchValue(cx, ok, err, m.GoVersion, x.GoVersion)
	return ok, err
}
