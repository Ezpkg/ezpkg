//go:build !genz

// Code generated by genz codez-matchers. DO NOT EDIT.

package codez

import (
	ast "go/ast"
	token "go/token"
)

// AssignStmt
type zAssignStmtMatcher struct {
	_ *ast.AssignStmt

	Lhs    ExprListMatcher[ast.Expr]
	TokPos token.Pos
	Tok    token.Token
	Rhs    ExprListMatcher[ast.Expr]
}

func (m zAssignStmtMatcher) MatchStmt(node ast.Stmt) (ok bool, err error) {
	return m.Match(node)
}
func (m zAssignStmtMatcher) Match(node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.AssignStmt)
	if !ok {
		return false, nil
	}
	ok, err = matchList(ok, err, m.Lhs, x.Lhs)
	ok, err = matchList(ok, err, m.Rhs, x.Rhs)
	return ok, err
}

// BlockStmt
type zBlockStmtMatcher struct {
	_ *ast.BlockStmt

	Lbrace token.Pos
	List   StmtListMatcher[ast.Stmt]
	Rbrace token.Pos
}

func (m zBlockStmtMatcher) MatchStmt(node ast.Stmt) (ok bool, err error) {
	return m.Match(node)
}
func (m zBlockStmtMatcher) Match(node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.BlockStmt)
	if !ok {
		return false, nil
	}
	ok, err = matchList(ok, err, m.List, x.List)
	return ok, err
}

// BranchStmt
type zBranchStmtMatcher struct {
	_ *ast.BranchStmt

	TokPos token.Pos
	Tok    token.Token
	Label  IdentMatcher
}

func (m zBranchStmtMatcher) MatchStmt(node ast.Stmt) (ok bool, err error) {
	return m.Match(node)
}
func (m zBranchStmtMatcher) Match(node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.BranchStmt)
	if !ok {
		return false, nil
	}
	ok, err = match(ok, err, m.Label, x.Label)
	return ok, err
}

// CaseClause
type zCaseClauseMatcher struct {
	_ *ast.CaseClause

	Case  token.Pos
	List  ExprListMatcher[ast.Expr]
	Colon token.Pos
	Body  StmtListMatcher[ast.Stmt]
}

func (m zCaseClauseMatcher) MatchStmt(node ast.Stmt) (ok bool, err error) {
	return m.Match(node)
}
func (m zCaseClauseMatcher) Match(node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.CaseClause)
	if !ok {
		return false, nil
	}
	ok, err = matchList(ok, err, m.List, x.List)
	ok, err = matchList(ok, err, m.Body, x.Body)
	return ok, err
}

// CommClause
type zCommClauseMatcher struct {
	_ *ast.CommClause

	Case  token.Pos
	Comm  StmtMatcher
	Colon token.Pos
	Body  StmtListMatcher[ast.Stmt]
}

func (m zCommClauseMatcher) MatchStmt(node ast.Stmt) (ok bool, err error) {
	return m.Match(node)
}
func (m zCommClauseMatcher) Match(node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.CommClause)
	if !ok {
		return false, nil
	}
	ok, err = match(ok, err, m.Comm, x.Comm)
	ok, err = matchList(ok, err, m.Body, x.Body)
	return ok, err
}

// DeclStmt
type zDeclStmtMatcher struct {
	_ *ast.DeclStmt

	Decl DeclMatcher
}

func (m zDeclStmtMatcher) MatchStmt(node ast.Stmt) (ok bool, err error) {
	return m.Match(node)
}
func (m zDeclStmtMatcher) Match(node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.DeclStmt)
	if !ok {
		return false, nil
	}
	ok, err = match(ok, err, m.Decl, x.Decl)
	return ok, err
}

// DeferStmt
type zDeferStmtMatcher struct {
	_ *ast.DeferStmt

	Defer token.Pos
	Call  CallExprMatcher
}

func (m zDeferStmtMatcher) MatchStmt(node ast.Stmt) (ok bool, err error) {
	return m.Match(node)
}
func (m zDeferStmtMatcher) Match(node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.DeferStmt)
	if !ok {
		return false, nil
	}
	ok, err = match(ok, err, m.Call, x.Call)
	return ok, err
}

// EmptyStmt
type zEmptyStmtMatcher struct {
	_ *ast.EmptyStmt

	Semicolon token.Pos
	Implicit  BoolMatcher
}

func (m zEmptyStmtMatcher) MatchStmt(node ast.Stmt) (ok bool, err error) {
	return m.Match(node)
}
func (m zEmptyStmtMatcher) Match(node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.EmptyStmt)
	if !ok {
		return false, nil
	}
	ok, err = matchValue(ok, err, m.Implicit, x.Implicit)
	return ok, err
}

// ExprStmt
type zExprStmtMatcher struct {
	_ *ast.ExprStmt

	X ExprMatcher
}

func (m zExprStmtMatcher) MatchStmt(node ast.Stmt) (ok bool, err error) {
	return m.Match(node)
}
func (m zExprStmtMatcher) Match(node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.ExprStmt)
	if !ok {
		return false, nil
	}
	ok, err = match(ok, err, m.X, x.X)
	return ok, err
}

// ForStmt
type zForStmtMatcher struct {
	_ *ast.ForStmt

	For  token.Pos
	Init StmtMatcher
	Cond ExprMatcher
	Post StmtMatcher
	Body BlockStmtMatcher
}

func (m zForStmtMatcher) MatchStmt(node ast.Stmt) (ok bool, err error) {
	return m.Match(node)
}
func (m zForStmtMatcher) Match(node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.ForStmt)
	if !ok {
		return false, nil
	}
	ok, err = match(ok, err, m.Init, x.Init)
	ok, err = match(ok, err, m.Cond, x.Cond)
	ok, err = match(ok, err, m.Post, x.Post)
	ok, err = match(ok, err, m.Body, x.Body)
	return ok, err
}

// GoStmt
type zGoStmtMatcher struct {
	_ *ast.GoStmt

	Go   token.Pos
	Call CallExprMatcher
}

func (m zGoStmtMatcher) MatchStmt(node ast.Stmt) (ok bool, err error) {
	return m.Match(node)
}
func (m zGoStmtMatcher) Match(node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.GoStmt)
	if !ok {
		return false, nil
	}
	ok, err = match(ok, err, m.Call, x.Call)
	return ok, err
}

// IfStmt
type zIfStmtMatcher struct {
	_ *ast.IfStmt

	If   token.Pos
	Init StmtMatcher
	Cond ExprMatcher
	Body BlockStmtMatcher
	Else StmtMatcher
}

func (m zIfStmtMatcher) MatchStmt(node ast.Stmt) (ok bool, err error) {
	return m.Match(node)
}
func (m zIfStmtMatcher) Match(node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.IfStmt)
	if !ok {
		return false, nil
	}
	ok, err = match(ok, err, m.Init, x.Init)
	ok, err = match(ok, err, m.Cond, x.Cond)
	ok, err = match(ok, err, m.Body, x.Body)
	ok, err = match(ok, err, m.Else, x.Else)
	return ok, err
}

// IncDecStmt
type zIncDecStmtMatcher struct {
	_ *ast.IncDecStmt

	X      ExprMatcher
	TokPos token.Pos
	Tok    token.Token
}

func (m zIncDecStmtMatcher) MatchStmt(node ast.Stmt) (ok bool, err error) {
	return m.Match(node)
}
func (m zIncDecStmtMatcher) Match(node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.IncDecStmt)
	if !ok {
		return false, nil
	}
	ok, err = match(ok, err, m.X, x.X)
	return ok, err
}

// LabeledStmt
type zLabeledStmtMatcher struct {
	_ *ast.LabeledStmt

	Label IdentMatcher
	Colon token.Pos
	Stmt  StmtMatcher
}

func (m zLabeledStmtMatcher) MatchStmt(node ast.Stmt) (ok bool, err error) {
	return m.Match(node)
}
func (m zLabeledStmtMatcher) Match(node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.LabeledStmt)
	if !ok {
		return false, nil
	}
	ok, err = match(ok, err, m.Label, x.Label)
	ok, err = match(ok, err, m.Stmt, x.Stmt)
	return ok, err
}

// RangeStmt
type zRangeStmtMatcher struct {
	_ *ast.RangeStmt

	For    token.Pos
	Key    ExprMatcher
	Value  ExprMatcher
	TokPos token.Pos
	Tok    token.Token
	Range  token.Pos
	X      ExprMatcher
	Body   BlockStmtMatcher
}

func (m zRangeStmtMatcher) MatchStmt(node ast.Stmt) (ok bool, err error) {
	return m.Match(node)
}
func (m zRangeStmtMatcher) Match(node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.RangeStmt)
	if !ok {
		return false, nil
	}
	ok, err = match(ok, err, m.Key, x.Key)
	ok, err = match(ok, err, m.Value, x.Value)
	ok, err = match(ok, err, m.X, x.X)
	ok, err = match(ok, err, m.Body, x.Body)
	return ok, err
}

// ReturnStmt
type zReturnStmtMatcher struct {
	_ *ast.ReturnStmt

	Return  token.Pos
	Results ExprListMatcher[ast.Expr]
}

func (m zReturnStmtMatcher) MatchStmt(node ast.Stmt) (ok bool, err error) {
	return m.Match(node)
}
func (m zReturnStmtMatcher) Match(node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.ReturnStmt)
	if !ok {
		return false, nil
	}
	ok, err = matchList(ok, err, m.Results, x.Results)
	return ok, err
}

// SelectStmt
type zSelectStmtMatcher struct {
	_ *ast.SelectStmt

	Select token.Pos
	Body   BlockStmtMatcher
}

func (m zSelectStmtMatcher) MatchStmt(node ast.Stmt) (ok bool, err error) {
	return m.Match(node)
}
func (m zSelectStmtMatcher) Match(node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.SelectStmt)
	if !ok {
		return false, nil
	}
	ok, err = match(ok, err, m.Body, x.Body)
	return ok, err
}

// SendStmt
type zSendStmtMatcher struct {
	_ *ast.SendStmt

	Chan  ExprMatcher
	Arrow token.Pos
	Value ExprMatcher
}

func (m zSendStmtMatcher) MatchStmt(node ast.Stmt) (ok bool, err error) {
	return m.Match(node)
}
func (m zSendStmtMatcher) Match(node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.SendStmt)
	if !ok {
		return false, nil
	}
	ok, err = match(ok, err, m.Chan, x.Chan)
	ok, err = match(ok, err, m.Value, x.Value)
	return ok, err
}

// SwitchStmt
type zSwitchStmtMatcher struct {
	_ *ast.SwitchStmt

	Switch token.Pos
	Init   StmtMatcher
	Tag    ExprMatcher
	Body   BlockStmtMatcher
}

func (m zSwitchStmtMatcher) MatchStmt(node ast.Stmt) (ok bool, err error) {
	return m.Match(node)
}
func (m zSwitchStmtMatcher) Match(node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.SwitchStmt)
	if !ok {
		return false, nil
	}
	ok, err = match(ok, err, m.Init, x.Init)
	ok, err = match(ok, err, m.Tag, x.Tag)
	ok, err = match(ok, err, m.Body, x.Body)
	return ok, err
}

// TypeSwitchStmt
type zTypeSwitchStmtMatcher struct {
	_ *ast.TypeSwitchStmt

	Switch token.Pos
	Init   StmtMatcher
	Assign StmtMatcher
	Body   BlockStmtMatcher
}

func (m zTypeSwitchStmtMatcher) MatchStmt(node ast.Stmt) (ok bool, err error) {
	return m.Match(node)
}
func (m zTypeSwitchStmtMatcher) Match(node ast.Node) (ok bool, err error) {
	x, ok := node.(*ast.TypeSwitchStmt)
	if !ok {
		return false, nil
	}
	ok, err = match(ok, err, m.Init, x.Init)
	ok, err = match(ok, err, m.Assign, x.Assign)
	ok, err = match(ok, err, m.Body, x.Body)
	return ok, err
}
