//go:build !genz

// Code generated by genz codez-matchers. DO NOT EDIT.

package codez

import (
	"fmt"
	"go/ast"
	"strconv"

	"ezpkg.io/errorz"
)

func (v *zVisitor) visitDecl(node ast.Decl) {
	switch x := node.(type) {
	case nil:
		return
	case *ast.FuncDecl:
		v.visitFuncDecl(x)
	case *ast.GenDecl:
		v.visitGenDecl(x)
	default:
		panic(fmt.Sprintf("unreachable: %s is ast.Decl ❌", node))
	}
}
func (v *zVisitor) visitExpr(node ast.Expr) {
	switch x := node.(type) {
	case nil:
		return
	case *ast.ArrayType:
		v.visitArrayType(x)
	case *ast.BasicLit:
		v.visitBasicLit(x)
	case *ast.BinaryExpr:
		v.visitBinaryExpr(x)
	case *ast.CallExpr:
		v.visitCallExpr(x)
	case *ast.ChanType:
		v.visitChanType(x)
	case *ast.CompositeLit:
		v.visitCompositeLit(x)
	case *ast.Ellipsis:
		v.visitEllipsis(x)
	case *ast.FuncLit:
		v.visitFuncLit(x)
	case *ast.FuncType:
		v.visitFuncType(x)
	case *ast.Ident:
		v.visitIdent(x)
	case *ast.IndexExpr:
		v.visitIndexExpr(x)
	case *ast.IndexListExpr:
		v.visitIndexListExpr(x)
	case *ast.InterfaceType:
		v.visitInterfaceType(x)
	case *ast.KeyValueExpr:
		v.visitKeyValueExpr(x)
	case *ast.MapType:
		v.visitMapType(x)
	case *ast.ParenExpr:
		v.visitParenExpr(x)
	case *ast.SelectorExpr:
		v.visitSelectorExpr(x)
	case *ast.SliceExpr:
		v.visitSliceExpr(x)
	case *ast.StarExpr:
		v.visitStarExpr(x)
	case *ast.StructType:
		v.visitStructType(x)
	case *ast.TypeAssertExpr:
		v.visitTypeAssertExpr(x)
	case *ast.UnaryExpr:
		v.visitUnaryExpr(x)
	default:
		panic(fmt.Sprintf("unreachable: %s is ast.Expr ❌", node))
	}
}
func (v *zVisitor) visitSpec(node ast.Spec) {
	switch x := node.(type) {
	case nil:
		return
	case *ast.ImportSpec:
		v.visitImportSpec(x)
	case *ast.TypeSpec:
		v.visitTypeSpec(x)
	case *ast.ValueSpec:
		v.visitValueSpec(x)
	default:
		panic(fmt.Sprintf("unreachable: %s is ast.Spec ❌", node))
	}
}
func (v *zVisitor) visitStmt(node ast.Stmt) {
	switch x := node.(type) {
	case nil:
		return
	case *ast.AssignStmt:
		v.visitAssignStmt(x)
	case *ast.BlockStmt:
		v.visitBlockStmt(x)
	case *ast.BranchStmt:
		v.visitBranchStmt(x)
	case *ast.CaseClause:
		v.visitCaseClause(x)
	case *ast.CommClause:
		v.visitCommClause(x)
	case *ast.DeclStmt:
		v.visitDeclStmt(x)
	case *ast.DeferStmt:
		v.visitDeferStmt(x)
	case *ast.EmptyStmt:
		v.visitEmptyStmt(x)
	case *ast.ExprStmt:
		v.visitExprStmt(x)
	case *ast.ForStmt:
		v.visitForStmt(x)
	case *ast.GoStmt:
		v.visitGoStmt(x)
	case *ast.IfStmt:
		v.visitIfStmt(x)
	case *ast.IncDecStmt:
		v.visitIncDecStmt(x)
	case *ast.LabeledStmt:
		v.visitLabeledStmt(x)
	case *ast.RangeStmt:
		v.visitRangeStmt(x)
	case *ast.ReturnStmt:
		v.visitReturnStmt(x)
	case *ast.SelectStmt:
		v.visitSelectStmt(x)
	case *ast.SendStmt:
		v.visitSendStmt(x)
	case *ast.SwitchStmt:
		v.visitSwitchStmt(x)
	case *ast.TypeSwitchStmt:
		v.visitTypeSwitchStmt(x)
	default:
		panic(fmt.Sprintf("unreachable: %s is ast.Stmt ❌", node))
	}
}
func (v *zVisitor) visitOther(node ast.Node) {
	switch x := node.(type) {
	case nil:
		return
	case *ast.Comment:
		v.visitComment(x)
	case *ast.CommentGroup:
		v.visitCommentGroup(x)
	case *ast.Field:
		v.visitField(x)
	case *ast.FieldList:
		v.visitFieldList(x)
	case *ast.File:
		v.visitFile(x)
	default:
		panic(fmt.Sprintf("unreachable: %s is ast.Other ❌", node))
	}
}

// ArrayType
func (v *zVisitor) visitArrayType(node *ast.ArrayType) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Len", node.Len)
		v.cx.replaceCurrent, v.cx.curIdx = replaceArrayType_Len, 0
		v.visitExpr(node.Len)
		v.cx.pop()
		v.cx.push("Elt", node.Elt)
		v.cx.replaceCurrent, v.cx.curIdx = replaceArrayType_Elt, 0
		v.visitExpr(node.Elt)
		v.cx.pop()
	}
}

// AssignStmt
func (v *zVisitor) visitAssignStmt(node *ast.AssignStmt) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Lhs", nil)
		v.cx.replaceCurrent = replaceAssignStmt_Lhs
		for i, item := range node.Lhs {
			v.cx.curIdx = i
			v.cx.push(strconv.Itoa(i), item)
			v.visitExpr(item)
			v.cx.pop()
		}
		v.cx.pop()

		v.cx.push("Rhs", nil)
		v.cx.replaceCurrent = replaceAssignStmt_Rhs
		for i, item := range node.Rhs {
			v.cx.curIdx = i
			v.cx.push(strconv.Itoa(i), item)
			v.visitExpr(item)
			v.cx.pop()
		}
		v.cx.pop()
	}
}

// BasicLit
func (v *zVisitor) visitBasicLit(node *ast.BasicLit) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
	}
}

// BinaryExpr
func (v *zVisitor) visitBinaryExpr(node *ast.BinaryExpr) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("X", node.X)
		v.cx.replaceCurrent, v.cx.curIdx = replaceBinaryExpr_X, 0
		v.visitExpr(node.X)
		v.cx.pop()
		v.cx.push("Y", node.Y)
		v.cx.replaceCurrent, v.cx.curIdx = replaceBinaryExpr_Y, 0
		v.visitExpr(node.Y)
		v.cx.pop()
	}
}

// BlockStmt
func (v *zVisitor) visitBlockStmt(node *ast.BlockStmt) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("List", nil)
		v.cx.replaceCurrent = replaceBlockStmt_List
		for i, item := range node.List {
			v.cx.curIdx = i
			v.cx.push(strconv.Itoa(i), item)
			v.visitStmt(item)
			v.cx.pop()
		}
		v.cx.pop()
	}
}

// BranchStmt
func (v *zVisitor) visitBranchStmt(node *ast.BranchStmt) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Label", node.Label)
		v.cx.replaceCurrent, v.cx.curIdx = replaceBranchStmt_Label, 0
		v.visitIdent(node.Label)
		v.cx.pop()
	}
}

// CallExpr
func (v *zVisitor) visitCallExpr(node *ast.CallExpr) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Fun", node.Fun)
		v.cx.replaceCurrent, v.cx.curIdx = replaceCallExpr_Fun, 0
		v.visitExpr(node.Fun)
		v.cx.pop()

		v.cx.push("Args", nil)
		v.cx.replaceCurrent = replaceCallExpr_Args
		for i, item := range node.Args {
			v.cx.curIdx = i
			v.cx.push(strconv.Itoa(i), item)
			v.visitExpr(item)
			v.cx.pop()
		}
		v.cx.pop()
	}
}

// CaseClause
func (v *zVisitor) visitCaseClause(node *ast.CaseClause) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("List", nil)
		v.cx.replaceCurrent = replaceCaseClause_List
		for i, item := range node.List {
			v.cx.curIdx = i
			v.cx.push(strconv.Itoa(i), item)
			v.visitExpr(item)
			v.cx.pop()
		}
		v.cx.pop()

		v.cx.push("Body", nil)
		v.cx.replaceCurrent = replaceCaseClause_Body
		for i, item := range node.Body {
			v.cx.curIdx = i
			v.cx.push(strconv.Itoa(i), item)
			v.visitStmt(item)
			v.cx.pop()
		}
		v.cx.pop()
	}
}

// ChanType
func (v *zVisitor) visitChanType(node *ast.ChanType) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Value", node.Value)
		v.cx.replaceCurrent, v.cx.curIdx = replaceChanType_Value, 0
		v.visitExpr(node.Value)
		v.cx.pop()
	}
}

// CommClause
func (v *zVisitor) visitCommClause(node *ast.CommClause) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Comm", node.Comm)
		v.cx.replaceCurrent, v.cx.curIdx = replaceCommClause_Comm, 0
		v.visitStmt(node.Comm)
		v.cx.pop()

		v.cx.push("Body", nil)
		v.cx.replaceCurrent = replaceCommClause_Body
		for i, item := range node.Body {
			v.cx.curIdx = i
			v.cx.push(strconv.Itoa(i), item)
			v.visitStmt(item)
			v.cx.pop()
		}
		v.cx.pop()
	}
}

// Comment
func (v *zVisitor) visitComment(node *ast.Comment) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
	}
}

// CommentGroup
func (v *zVisitor) visitCommentGroup(node *ast.CommentGroup) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("List", nil)
		v.cx.replaceCurrent = replaceCommentGroup_List
		for i, item := range node.List {
			v.cx.curIdx = i
			v.cx.push(strconv.Itoa(i), item)
			v.visitComment(item)
			v.cx.pop()
		}
		v.cx.pop()
	}
}

// CompositeLit
func (v *zVisitor) visitCompositeLit(node *ast.CompositeLit) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Type", node.Type)
		v.cx.replaceCurrent, v.cx.curIdx = replaceCompositeLit_Type, 0
		v.visitExpr(node.Type)
		v.cx.pop()

		v.cx.push("Elts", nil)
		v.cx.replaceCurrent = replaceCompositeLit_Elts
		for i, item := range node.Elts {
			v.cx.curIdx = i
			v.cx.push(strconv.Itoa(i), item)
			v.visitExpr(item)
			v.cx.pop()
		}
		v.cx.pop()
	}
}

// DeclStmt
func (v *zVisitor) visitDeclStmt(node *ast.DeclStmt) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Decl", node.Decl)
		v.cx.replaceCurrent, v.cx.curIdx = replaceDeclStmt_Decl, 0
		v.visitDecl(node.Decl)
		v.cx.pop()
	}
}

// DeferStmt
func (v *zVisitor) visitDeferStmt(node *ast.DeferStmt) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Call", node.Call)
		v.cx.replaceCurrent, v.cx.curIdx = replaceDeferStmt_Call, 0
		v.visitCallExpr(node.Call)
		v.cx.pop()
	}
}

// Ellipsis
func (v *zVisitor) visitEllipsis(node *ast.Ellipsis) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Elt", node.Elt)
		v.cx.replaceCurrent, v.cx.curIdx = replaceEllipsis_Elt, 0
		v.visitExpr(node.Elt)
		v.cx.pop()
	}
}

// EmptyStmt
func (v *zVisitor) visitEmptyStmt(node *ast.EmptyStmt) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
	}
}

// ExprStmt
func (v *zVisitor) visitExprStmt(node *ast.ExprStmt) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("X", node.X)
		v.cx.replaceCurrent, v.cx.curIdx = replaceExprStmt_X, 0
		v.visitExpr(node.X)
		v.cx.pop()
	}
}

// Field
func (v *zVisitor) visitField(node *ast.Field) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Doc", node.Doc)
		v.cx.replaceCurrent, v.cx.curIdx = replaceField_Doc, 0
		v.visitCommentGroup(node.Doc)
		v.cx.pop()

		v.cx.push("Names", nil)
		v.cx.replaceCurrent = replaceField_Names
		for i, item := range node.Names {
			v.cx.curIdx = i
			v.cx.push(strconv.Itoa(i), item)
			v.visitIdent(item)
			v.cx.pop()
		}
		v.cx.pop()
		v.cx.push("Type", node.Type)
		v.cx.replaceCurrent, v.cx.curIdx = replaceField_Type, 0
		v.visitExpr(node.Type)
		v.cx.pop()
		v.cx.push("Tag", node.Tag)
		v.cx.replaceCurrent, v.cx.curIdx = replaceField_Tag, 0
		v.visitBasicLit(node.Tag)
		v.cx.pop()
		v.cx.push("Comment", node.Comment)
		v.cx.replaceCurrent, v.cx.curIdx = replaceField_Comment, 0
		v.visitCommentGroup(node.Comment)
		v.cx.pop()
	}
}

// FieldList
func (v *zVisitor) visitFieldList(node *ast.FieldList) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("List", nil)
		v.cx.replaceCurrent = replaceFieldList_List
		for i, item := range node.List {
			v.cx.curIdx = i
			v.cx.push(strconv.Itoa(i), item)
			v.visitField(item)
			v.cx.pop()
		}
		v.cx.pop()
	}
}

// File
func (v *zVisitor) visitFile(node *ast.File) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Doc", node.Doc)
		v.cx.replaceCurrent, v.cx.curIdx = replaceFile_Doc, 0
		v.visitCommentGroup(node.Doc)
		v.cx.pop()
		v.cx.push("Name", node.Name)
		v.cx.replaceCurrent, v.cx.curIdx = replaceFile_Name, 0
		v.visitIdent(node.Name)
		v.cx.pop()

		v.cx.push("Decls", nil)
		v.cx.replaceCurrent = replaceFile_Decls
		for i, item := range node.Decls {
			v.cx.curIdx = i
			v.cx.push(strconv.Itoa(i), item)
			v.visitDecl(item)
			v.cx.pop()
		}
		v.cx.pop()

		v.cx.push("Imports", nil)
		v.cx.replaceCurrent = replaceFile_Imports
		for i, item := range node.Imports {
			v.cx.curIdx = i
			v.cx.push(strconv.Itoa(i), item)
			v.visitImportSpec(item)
			v.cx.pop()
		}
		v.cx.pop()

		v.cx.push("Comments", nil)
		v.cx.replaceCurrent = replaceFile_Comments
		for i, item := range node.Comments {
			v.cx.curIdx = i
			v.cx.push(strconv.Itoa(i), item)
			v.visitCommentGroup(item)
			v.cx.pop()
		}
		v.cx.pop()
	}
}

// ForStmt
func (v *zVisitor) visitForStmt(node *ast.ForStmt) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Init", node.Init)
		v.cx.replaceCurrent, v.cx.curIdx = replaceForStmt_Init, 0
		v.visitStmt(node.Init)
		v.cx.pop()
		v.cx.push("Cond", node.Cond)
		v.cx.replaceCurrent, v.cx.curIdx = replaceForStmt_Cond, 0
		v.visitExpr(node.Cond)
		v.cx.pop()
		v.cx.push("Post", node.Post)
		v.cx.replaceCurrent, v.cx.curIdx = replaceForStmt_Post, 0
		v.visitStmt(node.Post)
		v.cx.pop()
		v.cx.push("Body", node.Body)
		v.cx.replaceCurrent, v.cx.curIdx = replaceForStmt_Body, 0
		v.visitBlockStmt(node.Body)
		v.cx.pop()
	}
}

// FuncDecl
func (v *zVisitor) visitFuncDecl(node *ast.FuncDecl) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Doc", node.Doc)
		v.cx.replaceCurrent, v.cx.curIdx = replaceFuncDecl_Doc, 0
		v.visitCommentGroup(node.Doc)
		v.cx.pop()
		v.cx.push("Recv", node.Recv)
		v.cx.replaceCurrent, v.cx.curIdx = replaceFuncDecl_Recv, 0
		v.visitFieldList(node.Recv)
		v.cx.pop()
		v.cx.push("Name", node.Name)
		v.cx.replaceCurrent, v.cx.curIdx = replaceFuncDecl_Name, 0
		v.visitIdent(node.Name)
		v.cx.pop()
		v.cx.push("Type", node.Type)
		v.cx.replaceCurrent, v.cx.curIdx = replaceFuncDecl_Type, 0
		v.visitFuncType(node.Type)
		v.cx.pop()
		v.cx.push("Body", node.Body)
		v.cx.replaceCurrent, v.cx.curIdx = replaceFuncDecl_Body, 0
		v.visitBlockStmt(node.Body)
		v.cx.pop()
	}
}

// FuncLit
func (v *zVisitor) visitFuncLit(node *ast.FuncLit) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Type", node.Type)
		v.cx.replaceCurrent, v.cx.curIdx = replaceFuncLit_Type, 0
		v.visitFuncType(node.Type)
		v.cx.pop()
		v.cx.push("Body", node.Body)
		v.cx.replaceCurrent, v.cx.curIdx = replaceFuncLit_Body, 0
		v.visitBlockStmt(node.Body)
		v.cx.pop()
	}
}

// FuncType
func (v *zVisitor) visitFuncType(node *ast.FuncType) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("TypeParams", node.TypeParams)
		v.cx.replaceCurrent, v.cx.curIdx = replaceFuncType_TypeParams, 0
		v.visitFieldList(node.TypeParams)
		v.cx.pop()
		v.cx.push("Params", node.Params)
		v.cx.replaceCurrent, v.cx.curIdx = replaceFuncType_Params, 0
		v.visitFieldList(node.Params)
		v.cx.pop()
		v.cx.push("Results", node.Results)
		v.cx.replaceCurrent, v.cx.curIdx = replaceFuncType_Results, 0
		v.visitFieldList(node.Results)
		v.cx.pop()
	}
}

// GenDecl
func (v *zVisitor) visitGenDecl(node *ast.GenDecl) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Doc", node.Doc)
		v.cx.replaceCurrent, v.cx.curIdx = replaceGenDecl_Doc, 0
		v.visitCommentGroup(node.Doc)
		v.cx.pop()

		v.cx.push("Specs", nil)
		v.cx.replaceCurrent = replaceGenDecl_Specs
		for i, item := range node.Specs {
			v.cx.curIdx = i
			v.cx.push(strconv.Itoa(i), item)
			v.visitSpec(item)
			v.cx.pop()
		}
		v.cx.pop()
	}
}

// GoStmt
func (v *zVisitor) visitGoStmt(node *ast.GoStmt) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Call", node.Call)
		v.cx.replaceCurrent, v.cx.curIdx = replaceGoStmt_Call, 0
		v.visitCallExpr(node.Call)
		v.cx.pop()
	}
}

// Ident
func (v *zVisitor) visitIdent(node *ast.Ident) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
	}
}

// IfStmt
func (v *zVisitor) visitIfStmt(node *ast.IfStmt) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Init", node.Init)
		v.cx.replaceCurrent, v.cx.curIdx = replaceIfStmt_Init, 0
		v.visitStmt(node.Init)
		v.cx.pop()
		v.cx.push("Cond", node.Cond)
		v.cx.replaceCurrent, v.cx.curIdx = replaceIfStmt_Cond, 0
		v.visitExpr(node.Cond)
		v.cx.pop()
		v.cx.push("Body", node.Body)
		v.cx.replaceCurrent, v.cx.curIdx = replaceIfStmt_Body, 0
		v.visitBlockStmt(node.Body)
		v.cx.pop()
		v.cx.push("Else", node.Else)
		v.cx.replaceCurrent, v.cx.curIdx = replaceIfStmt_Else, 0
		v.visitStmt(node.Else)
		v.cx.pop()
	}
}

// ImportSpec
func (v *zVisitor) visitImportSpec(node *ast.ImportSpec) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Doc", node.Doc)
		v.cx.replaceCurrent, v.cx.curIdx = replaceImportSpec_Doc, 0
		v.visitCommentGroup(node.Doc)
		v.cx.pop()
		v.cx.push("Name", node.Name)
		v.cx.replaceCurrent, v.cx.curIdx = replaceImportSpec_Name, 0
		v.visitIdent(node.Name)
		v.cx.pop()
		v.cx.push("Path", node.Path)
		v.cx.replaceCurrent, v.cx.curIdx = replaceImportSpec_Path, 0
		v.visitBasicLit(node.Path)
		v.cx.pop()
		v.cx.push("Comment", node.Comment)
		v.cx.replaceCurrent, v.cx.curIdx = replaceImportSpec_Comment, 0
		v.visitCommentGroup(node.Comment)
		v.cx.pop()
	}
}

// IncDecStmt
func (v *zVisitor) visitIncDecStmt(node *ast.IncDecStmt) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("X", node.X)
		v.cx.replaceCurrent, v.cx.curIdx = replaceIncDecStmt_X, 0
		v.visitExpr(node.X)
		v.cx.pop()
	}
}

// IndexExpr
func (v *zVisitor) visitIndexExpr(node *ast.IndexExpr) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("X", node.X)
		v.cx.replaceCurrent, v.cx.curIdx = replaceIndexExpr_X, 0
		v.visitExpr(node.X)
		v.cx.pop()
		v.cx.push("Index", node.Index)
		v.cx.replaceCurrent, v.cx.curIdx = replaceIndexExpr_Index, 0
		v.visitExpr(node.Index)
		v.cx.pop()
	}
}

// IndexListExpr
func (v *zVisitor) visitIndexListExpr(node *ast.IndexListExpr) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("X", node.X)
		v.cx.replaceCurrent, v.cx.curIdx = replaceIndexListExpr_X, 0
		v.visitExpr(node.X)
		v.cx.pop()

		v.cx.push("Indices", nil)
		v.cx.replaceCurrent = replaceIndexListExpr_Indices
		for i, item := range node.Indices {
			v.cx.curIdx = i
			v.cx.push(strconv.Itoa(i), item)
			v.visitExpr(item)
			v.cx.pop()
		}
		v.cx.pop()
	}
}

// InterfaceType
func (v *zVisitor) visitInterfaceType(node *ast.InterfaceType) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Methods", node.Methods)
		v.cx.replaceCurrent, v.cx.curIdx = replaceInterfaceType_Methods, 0
		v.visitFieldList(node.Methods)
		v.cx.pop()
	}
}

// KeyValueExpr
func (v *zVisitor) visitKeyValueExpr(node *ast.KeyValueExpr) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Key", node.Key)
		v.cx.replaceCurrent, v.cx.curIdx = replaceKeyValueExpr_Key, 0
		v.visitExpr(node.Key)
		v.cx.pop()
		v.cx.push("Value", node.Value)
		v.cx.replaceCurrent, v.cx.curIdx = replaceKeyValueExpr_Value, 0
		v.visitExpr(node.Value)
		v.cx.pop()
	}
}

// LabeledStmt
func (v *zVisitor) visitLabeledStmt(node *ast.LabeledStmt) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Label", node.Label)
		v.cx.replaceCurrent, v.cx.curIdx = replaceLabeledStmt_Label, 0
		v.visitIdent(node.Label)
		v.cx.pop()
		v.cx.push("Stmt", node.Stmt)
		v.cx.replaceCurrent, v.cx.curIdx = replaceLabeledStmt_Stmt, 0
		v.visitStmt(node.Stmt)
		v.cx.pop()
	}
}

// MapType
func (v *zVisitor) visitMapType(node *ast.MapType) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Key", node.Key)
		v.cx.replaceCurrent, v.cx.curIdx = replaceMapType_Key, 0
		v.visitExpr(node.Key)
		v.cx.pop()
		v.cx.push("Value", node.Value)
		v.cx.replaceCurrent, v.cx.curIdx = replaceMapType_Value, 0
		v.visitExpr(node.Value)
		v.cx.pop()
	}
}

// ParenExpr
func (v *zVisitor) visitParenExpr(node *ast.ParenExpr) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("X", node.X)
		v.cx.replaceCurrent, v.cx.curIdx = replaceParenExpr_X, 0
		v.visitExpr(node.X)
		v.cx.pop()
	}
}

// RangeStmt
func (v *zVisitor) visitRangeStmt(node *ast.RangeStmt) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Key", node.Key)
		v.cx.replaceCurrent, v.cx.curIdx = replaceRangeStmt_Key, 0
		v.visitExpr(node.Key)
		v.cx.pop()
		v.cx.push("Value", node.Value)
		v.cx.replaceCurrent, v.cx.curIdx = replaceRangeStmt_Value, 0
		v.visitExpr(node.Value)
		v.cx.pop()
		v.cx.push("X", node.X)
		v.cx.replaceCurrent, v.cx.curIdx = replaceRangeStmt_X, 0
		v.visitExpr(node.X)
		v.cx.pop()
		v.cx.push("Body", node.Body)
		v.cx.replaceCurrent, v.cx.curIdx = replaceRangeStmt_Body, 0
		v.visitBlockStmt(node.Body)
		v.cx.pop()
	}
}

// ReturnStmt
func (v *zVisitor) visitReturnStmt(node *ast.ReturnStmt) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Results", nil)
		v.cx.replaceCurrent = replaceReturnStmt_Results
		for i, item := range node.Results {
			v.cx.curIdx = i
			v.cx.push(strconv.Itoa(i), item)
			v.visitExpr(item)
			v.cx.pop()
		}
		v.cx.pop()
	}
}

// SelectStmt
func (v *zVisitor) visitSelectStmt(node *ast.SelectStmt) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Body", node.Body)
		v.cx.replaceCurrent, v.cx.curIdx = replaceSelectStmt_Body, 0
		v.visitBlockStmt(node.Body)
		v.cx.pop()
	}
}

// SelectorExpr
func (v *zVisitor) visitSelectorExpr(node *ast.SelectorExpr) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("X", node.X)
		v.cx.replaceCurrent, v.cx.curIdx = replaceSelectorExpr_X, 0
		v.visitExpr(node.X)
		v.cx.pop()
		v.cx.push("Sel", node.Sel)
		v.cx.replaceCurrent, v.cx.curIdx = replaceSelectorExpr_Sel, 0
		v.visitIdent(node.Sel)
		v.cx.pop()
	}
}

// SendStmt
func (v *zVisitor) visitSendStmt(node *ast.SendStmt) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Chan", node.Chan)
		v.cx.replaceCurrent, v.cx.curIdx = replaceSendStmt_Chan, 0
		v.visitExpr(node.Chan)
		v.cx.pop()
		v.cx.push("Value", node.Value)
		v.cx.replaceCurrent, v.cx.curIdx = replaceSendStmt_Value, 0
		v.visitExpr(node.Value)
		v.cx.pop()
	}
}

// SliceExpr
func (v *zVisitor) visitSliceExpr(node *ast.SliceExpr) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("X", node.X)
		v.cx.replaceCurrent, v.cx.curIdx = replaceSliceExpr_X, 0
		v.visitExpr(node.X)
		v.cx.pop()
		v.cx.push("Low", node.Low)
		v.cx.replaceCurrent, v.cx.curIdx = replaceSliceExpr_Low, 0
		v.visitExpr(node.Low)
		v.cx.pop()
		v.cx.push("High", node.High)
		v.cx.replaceCurrent, v.cx.curIdx = replaceSliceExpr_High, 0
		v.visitExpr(node.High)
		v.cx.pop()
		v.cx.push("Max", node.Max)
		v.cx.replaceCurrent, v.cx.curIdx = replaceSliceExpr_Max, 0
		v.visitExpr(node.Max)
		v.cx.pop()
	}
}

// StarExpr
func (v *zVisitor) visitStarExpr(node *ast.StarExpr) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("X", node.X)
		v.cx.replaceCurrent, v.cx.curIdx = replaceStarExpr_X, 0
		v.visitExpr(node.X)
		v.cx.pop()
	}
}

// StructType
func (v *zVisitor) visitStructType(node *ast.StructType) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Fields", node.Fields)
		v.cx.replaceCurrent, v.cx.curIdx = replaceStructType_Fields, 0
		v.visitFieldList(node.Fields)
		v.cx.pop()
	}
}

// SwitchStmt
func (v *zVisitor) visitSwitchStmt(node *ast.SwitchStmt) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Init", node.Init)
		v.cx.replaceCurrent, v.cx.curIdx = replaceSwitchStmt_Init, 0
		v.visitStmt(node.Init)
		v.cx.pop()
		v.cx.push("Tag", node.Tag)
		v.cx.replaceCurrent, v.cx.curIdx = replaceSwitchStmt_Tag, 0
		v.visitExpr(node.Tag)
		v.cx.pop()
		v.cx.push("Body", node.Body)
		v.cx.replaceCurrent, v.cx.curIdx = replaceSwitchStmt_Body, 0
		v.visitBlockStmt(node.Body)
		v.cx.pop()
	}
}

// TypeAssertExpr
func (v *zVisitor) visitTypeAssertExpr(node *ast.TypeAssertExpr) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("X", node.X)
		v.cx.replaceCurrent, v.cx.curIdx = replaceTypeAssertExpr_X, 0
		v.visitExpr(node.X)
		v.cx.pop()
		v.cx.push("Type", node.Type)
		v.cx.replaceCurrent, v.cx.curIdx = replaceTypeAssertExpr_Type, 0
		v.visitExpr(node.Type)
		v.cx.pop()
	}
}

// TypeSpec
func (v *zVisitor) visitTypeSpec(node *ast.TypeSpec) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Doc", node.Doc)
		v.cx.replaceCurrent, v.cx.curIdx = replaceTypeSpec_Doc, 0
		v.visitCommentGroup(node.Doc)
		v.cx.pop()
		v.cx.push("Name", node.Name)
		v.cx.replaceCurrent, v.cx.curIdx = replaceTypeSpec_Name, 0
		v.visitIdent(node.Name)
		v.cx.pop()
		v.cx.push("TypeParams", node.TypeParams)
		v.cx.replaceCurrent, v.cx.curIdx = replaceTypeSpec_TypeParams, 0
		v.visitFieldList(node.TypeParams)
		v.cx.pop()
		v.cx.push("Type", node.Type)
		v.cx.replaceCurrent, v.cx.curIdx = replaceTypeSpec_Type, 0
		v.visitExpr(node.Type)
		v.cx.pop()
		v.cx.push("Comment", node.Comment)
		v.cx.replaceCurrent, v.cx.curIdx = replaceTypeSpec_Comment, 0
		v.visitCommentGroup(node.Comment)
		v.cx.pop()
	}
}

// TypeSwitchStmt
func (v *zVisitor) visitTypeSwitchStmt(node *ast.TypeSwitchStmt) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Init", node.Init)
		v.cx.replaceCurrent, v.cx.curIdx = replaceTypeSwitchStmt_Init, 0
		v.visitStmt(node.Init)
		v.cx.pop()
		v.cx.push("Assign", node.Assign)
		v.cx.replaceCurrent, v.cx.curIdx = replaceTypeSwitchStmt_Assign, 0
		v.visitStmt(node.Assign)
		v.cx.pop()
		v.cx.push("Body", node.Body)
		v.cx.replaceCurrent, v.cx.curIdx = replaceTypeSwitchStmt_Body, 0
		v.visitBlockStmt(node.Body)
		v.cx.pop()
	}
}

// UnaryExpr
func (v *zVisitor) visitUnaryExpr(node *ast.UnaryExpr) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("X", node.X)
		v.cx.replaceCurrent, v.cx.curIdx = replaceUnaryExpr_X, 0
		v.visitExpr(node.X)
		v.cx.pop()
	}
}

// ValueSpec
func (v *zVisitor) visitValueSpec(node *ast.ValueSpec) {
	ok := node != nil && v.fn(v.cx, node)
	if ok {
		v.cx.push("Doc", node.Doc)
		v.cx.replaceCurrent, v.cx.curIdx = replaceValueSpec_Doc, 0
		v.visitCommentGroup(node.Doc)
		v.cx.pop()

		v.cx.push("Names", nil)
		v.cx.replaceCurrent = replaceValueSpec_Names
		for i, item := range node.Names {
			v.cx.curIdx = i
			v.cx.push(strconv.Itoa(i), item)
			v.visitIdent(item)
			v.cx.pop()
		}
		v.cx.pop()
		v.cx.push("Type", node.Type)
		v.cx.replaceCurrent, v.cx.curIdx = replaceValueSpec_Type, 0
		v.visitExpr(node.Type)
		v.cx.pop()

		v.cx.push("Values", nil)
		v.cx.replaceCurrent = replaceValueSpec_Values
		for i, item := range node.Values {
			v.cx.curIdx = i
			v.cx.push(strconv.Itoa(i), item)
			v.visitExpr(item)
			v.cx.pop()
		}
		v.cx.pop()
		v.cx.push("Comment", node.Comment)
		v.cx.replaceCurrent, v.cx.curIdx = replaceValueSpec_Comment, 0
		v.visitCommentGroup(node.Comment)
		v.cx.pop()
	}
}

// --- replace functions ---

func replaceArrayType_Len(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.ArrayType)
	if !ok {
		return errorz.New("parent is not *ast.ArrayType")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Len = n
	return nil
}

func replaceArrayType_Elt(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.ArrayType)
	if !ok {
		return errorz.New("parent is not *ast.ArrayType")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Elt = n
	return nil
}

func replaceAssignStmt_Lhs(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.AssignStmt)
	if !ok {
		return errorz.New("parent is not *ast.AssignStmt")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	switch {
	case idx < 0 || idx > len(p.Lhs):
		return errorz.Newf("index out of range (idx=%s, len=%s)", idx, len(p.Lhs))
	case idx == len(p.Lhs):
		p.Lhs = append(p.Lhs, n)
	default:
		p.Lhs[idx] = n
	}
	return nil
}

func replaceAssignStmt_Rhs(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.AssignStmt)
	if !ok {
		return errorz.New("parent is not *ast.AssignStmt")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	switch {
	case idx < 0 || idx > len(p.Rhs):
		return errorz.Newf("index out of range (idx=%s, len=%s)", idx, len(p.Rhs))
	case idx == len(p.Rhs):
		p.Rhs = append(p.Rhs, n)
	default:
		p.Rhs[idx] = n
	}
	return nil
}

func replaceBinaryExpr_X(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.BinaryExpr)
	if !ok {
		return errorz.New("parent is not *ast.BinaryExpr")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.X = n
	return nil
}

func replaceBinaryExpr_Y(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.BinaryExpr)
	if !ok {
		return errorz.New("parent is not *ast.BinaryExpr")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Y = n
	return nil
}

func replaceBlockStmt_List(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.BlockStmt)
	if !ok {
		return errorz.New("parent is not *ast.BlockStmt")
	}
	n, ok := new.(ast.Stmt)
	if !ok {
		return errorz.New("new is not ast.Stmt")
	}
	switch {
	case idx < 0 || idx > len(p.List):
		return errorz.Newf("index out of range (idx=%s, len=%s)", idx, len(p.List))
	case idx == len(p.List):
		p.List = append(p.List, n)
	default:
		p.List[idx] = n
	}
	return nil
}

func replaceBranchStmt_Label(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.BranchStmt)
	if !ok {
		return errorz.New("parent is not *ast.BranchStmt")
	}
	n, ok := new.(*ast.Ident)
	if !ok {
		return errorz.New("new is not *ast.Ident")
	}
	p.Label = n
	return nil
}

func replaceCallExpr_Fun(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.CallExpr)
	if !ok {
		return errorz.New("parent is not *ast.CallExpr")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Fun = n
	return nil
}

func replaceCallExpr_Args(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.CallExpr)
	if !ok {
		return errorz.New("parent is not *ast.CallExpr")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	switch {
	case idx < 0 || idx > len(p.Args):
		return errorz.Newf("index out of range (idx=%s, len=%s)", idx, len(p.Args))
	case idx == len(p.Args):
		p.Args = append(p.Args, n)
	default:
		p.Args[idx] = n
	}
	return nil
}

func replaceCaseClause_List(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.CaseClause)
	if !ok {
		return errorz.New("parent is not *ast.CaseClause")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	switch {
	case idx < 0 || idx > len(p.List):
		return errorz.Newf("index out of range (idx=%s, len=%s)", idx, len(p.List))
	case idx == len(p.List):
		p.List = append(p.List, n)
	default:
		p.List[idx] = n
	}
	return nil
}

func replaceCaseClause_Body(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.CaseClause)
	if !ok {
		return errorz.New("parent is not *ast.CaseClause")
	}
	n, ok := new.(ast.Stmt)
	if !ok {
		return errorz.New("new is not ast.Stmt")
	}
	switch {
	case idx < 0 || idx > len(p.Body):
		return errorz.Newf("index out of range (idx=%s, len=%s)", idx, len(p.Body))
	case idx == len(p.Body):
		p.Body = append(p.Body, n)
	default:
		p.Body[idx] = n
	}
	return nil
}

func replaceChanType_Value(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.ChanType)
	if !ok {
		return errorz.New("parent is not *ast.ChanType")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Value = n
	return nil
}

func replaceCommClause_Comm(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.CommClause)
	if !ok {
		return errorz.New("parent is not *ast.CommClause")
	}
	n, ok := new.(ast.Stmt)
	if !ok {
		return errorz.New("new is not ast.Stmt")
	}
	p.Comm = n
	return nil
}

func replaceCommClause_Body(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.CommClause)
	if !ok {
		return errorz.New("parent is not *ast.CommClause")
	}
	n, ok := new.(ast.Stmt)
	if !ok {
		return errorz.New("new is not ast.Stmt")
	}
	switch {
	case idx < 0 || idx > len(p.Body):
		return errorz.Newf("index out of range (idx=%s, len=%s)", idx, len(p.Body))
	case idx == len(p.Body):
		p.Body = append(p.Body, n)
	default:
		p.Body[idx] = n
	}
	return nil
}

func replaceCommentGroup_List(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.CommentGroup)
	if !ok {
		return errorz.New("parent is not *ast.CommentGroup")
	}
	n, ok := new.(*ast.Comment)
	if !ok {
		return errorz.New("new is not *ast.Comment")
	}
	switch {
	case idx < 0 || idx > len(p.List):
		return errorz.Newf("index out of range (idx=%s, len=%s)", idx, len(p.List))
	case idx == len(p.List):
		p.List = append(p.List, n)
	default:
		p.List[idx] = n
	}
	return nil
}

func replaceCompositeLit_Type(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.CompositeLit)
	if !ok {
		return errorz.New("parent is not *ast.CompositeLit")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Type = n
	return nil
}

func replaceCompositeLit_Elts(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.CompositeLit)
	if !ok {
		return errorz.New("parent is not *ast.CompositeLit")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	switch {
	case idx < 0 || idx > len(p.Elts):
		return errorz.Newf("index out of range (idx=%s, len=%s)", idx, len(p.Elts))
	case idx == len(p.Elts):
		p.Elts = append(p.Elts, n)
	default:
		p.Elts[idx] = n
	}
	return nil
}

func replaceDeclStmt_Decl(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.DeclStmt)
	if !ok {
		return errorz.New("parent is not *ast.DeclStmt")
	}
	n, ok := new.(ast.Decl)
	if !ok {
		return errorz.New("new is not ast.Decl")
	}
	p.Decl = n
	return nil
}

func replaceDeferStmt_Call(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.DeferStmt)
	if !ok {
		return errorz.New("parent is not *ast.DeferStmt")
	}
	n, ok := new.(*ast.CallExpr)
	if !ok {
		return errorz.New("new is not *ast.CallExpr")
	}
	p.Call = n
	return nil
}

func replaceEllipsis_Elt(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.Ellipsis)
	if !ok {
		return errorz.New("parent is not *ast.Ellipsis")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Elt = n
	return nil
}

func replaceExprStmt_X(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.ExprStmt)
	if !ok {
		return errorz.New("parent is not *ast.ExprStmt")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.X = n
	return nil
}

func replaceField_Doc(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.Field)
	if !ok {
		return errorz.New("parent is not *ast.Field")
	}
	n, ok := new.(*ast.CommentGroup)
	if !ok {
		return errorz.New("new is not *ast.CommentGroup")
	}
	p.Doc = n
	return nil
}

func replaceField_Names(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.Field)
	if !ok {
		return errorz.New("parent is not *ast.Field")
	}
	n, ok := new.(*ast.Ident)
	if !ok {
		return errorz.New("new is not *ast.Ident")
	}
	switch {
	case idx < 0 || idx > len(p.Names):
		return errorz.Newf("index out of range (idx=%s, len=%s)", idx, len(p.Names))
	case idx == len(p.Names):
		p.Names = append(p.Names, n)
	default:
		p.Names[idx] = n
	}
	return nil
}

func replaceField_Type(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.Field)
	if !ok {
		return errorz.New("parent is not *ast.Field")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Type = n
	return nil
}

func replaceField_Tag(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.Field)
	if !ok {
		return errorz.New("parent is not *ast.Field")
	}
	n, ok := new.(*ast.BasicLit)
	if !ok {
		return errorz.New("new is not *ast.BasicLit")
	}
	p.Tag = n
	return nil
}

func replaceField_Comment(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.Field)
	if !ok {
		return errorz.New("parent is not *ast.Field")
	}
	n, ok := new.(*ast.CommentGroup)
	if !ok {
		return errorz.New("new is not *ast.CommentGroup")
	}
	p.Comment = n
	return nil
}

func replaceFieldList_List(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.FieldList)
	if !ok {
		return errorz.New("parent is not *ast.FieldList")
	}
	n, ok := new.(*ast.Field)
	if !ok {
		return errorz.New("new is not *ast.Field")
	}
	switch {
	case idx < 0 || idx > len(p.List):
		return errorz.Newf("index out of range (idx=%s, len=%s)", idx, len(p.List))
	case idx == len(p.List):
		p.List = append(p.List, n)
	default:
		p.List[idx] = n
	}
	return nil
}

func replaceFile_Doc(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.File)
	if !ok {
		return errorz.New("parent is not *ast.File")
	}
	n, ok := new.(*ast.CommentGroup)
	if !ok {
		return errorz.New("new is not *ast.CommentGroup")
	}
	p.Doc = n
	return nil
}

func replaceFile_Name(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.File)
	if !ok {
		return errorz.New("parent is not *ast.File")
	}
	n, ok := new.(*ast.Ident)
	if !ok {
		return errorz.New("new is not *ast.Ident")
	}
	p.Name = n
	return nil
}

func replaceFile_Decls(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.File)
	if !ok {
		return errorz.New("parent is not *ast.File")
	}
	n, ok := new.(ast.Decl)
	if !ok {
		return errorz.New("new is not ast.Decl")
	}
	switch {
	case idx < 0 || idx > len(p.Decls):
		return errorz.Newf("index out of range (idx=%s, len=%s)", idx, len(p.Decls))
	case idx == len(p.Decls):
		p.Decls = append(p.Decls, n)
	default:
		p.Decls[idx] = n
	}
	return nil
}

func replaceFile_Imports(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.File)
	if !ok {
		return errorz.New("parent is not *ast.File")
	}
	n, ok := new.(*ast.ImportSpec)
	if !ok {
		return errorz.New("new is not *ast.ImportSpec")
	}
	switch {
	case idx < 0 || idx > len(p.Imports):
		return errorz.Newf("index out of range (idx=%s, len=%s)", idx, len(p.Imports))
	case idx == len(p.Imports):
		p.Imports = append(p.Imports, n)
	default:
		p.Imports[idx] = n
	}
	return nil
}

func replaceFile_Comments(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.File)
	if !ok {
		return errorz.New("parent is not *ast.File")
	}
	n, ok := new.(*ast.CommentGroup)
	if !ok {
		return errorz.New("new is not *ast.CommentGroup")
	}
	switch {
	case idx < 0 || idx > len(p.Comments):
		return errorz.Newf("index out of range (idx=%s, len=%s)", idx, len(p.Comments))
	case idx == len(p.Comments):
		p.Comments = append(p.Comments, n)
	default:
		p.Comments[idx] = n
	}
	return nil
}

func replaceForStmt_Init(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.ForStmt)
	if !ok {
		return errorz.New("parent is not *ast.ForStmt")
	}
	n, ok := new.(ast.Stmt)
	if !ok {
		return errorz.New("new is not ast.Stmt")
	}
	p.Init = n
	return nil
}

func replaceForStmt_Cond(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.ForStmt)
	if !ok {
		return errorz.New("parent is not *ast.ForStmt")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Cond = n
	return nil
}

func replaceForStmt_Post(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.ForStmt)
	if !ok {
		return errorz.New("parent is not *ast.ForStmt")
	}
	n, ok := new.(ast.Stmt)
	if !ok {
		return errorz.New("new is not ast.Stmt")
	}
	p.Post = n
	return nil
}

func replaceForStmt_Body(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.ForStmt)
	if !ok {
		return errorz.New("parent is not *ast.ForStmt")
	}
	n, ok := new.(*ast.BlockStmt)
	if !ok {
		return errorz.New("new is not *ast.BlockStmt")
	}
	p.Body = n
	return nil
}

func replaceFuncDecl_Doc(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.FuncDecl)
	if !ok {
		return errorz.New("parent is not *ast.FuncDecl")
	}
	n, ok := new.(*ast.CommentGroup)
	if !ok {
		return errorz.New("new is not *ast.CommentGroup")
	}
	p.Doc = n
	return nil
}

func replaceFuncDecl_Recv(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.FuncDecl)
	if !ok {
		return errorz.New("parent is not *ast.FuncDecl")
	}
	n, ok := new.(*ast.FieldList)
	if !ok {
		return errorz.New("new is not *ast.FieldList")
	}
	p.Recv = n
	return nil
}

func replaceFuncDecl_Name(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.FuncDecl)
	if !ok {
		return errorz.New("parent is not *ast.FuncDecl")
	}
	n, ok := new.(*ast.Ident)
	if !ok {
		return errorz.New("new is not *ast.Ident")
	}
	p.Name = n
	return nil
}

func replaceFuncDecl_Type(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.FuncDecl)
	if !ok {
		return errorz.New("parent is not *ast.FuncDecl")
	}
	n, ok := new.(*ast.FuncType)
	if !ok {
		return errorz.New("new is not *ast.FuncType")
	}
	p.Type = n
	return nil
}

func replaceFuncDecl_Body(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.FuncDecl)
	if !ok {
		return errorz.New("parent is not *ast.FuncDecl")
	}
	n, ok := new.(*ast.BlockStmt)
	if !ok {
		return errorz.New("new is not *ast.BlockStmt")
	}
	p.Body = n
	return nil
}

func replaceFuncLit_Type(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.FuncLit)
	if !ok {
		return errorz.New("parent is not *ast.FuncLit")
	}
	n, ok := new.(*ast.FuncType)
	if !ok {
		return errorz.New("new is not *ast.FuncType")
	}
	p.Type = n
	return nil
}

func replaceFuncLit_Body(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.FuncLit)
	if !ok {
		return errorz.New("parent is not *ast.FuncLit")
	}
	n, ok := new.(*ast.BlockStmt)
	if !ok {
		return errorz.New("new is not *ast.BlockStmt")
	}
	p.Body = n
	return nil
}

func replaceFuncType_TypeParams(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.FuncType)
	if !ok {
		return errorz.New("parent is not *ast.FuncType")
	}
	n, ok := new.(*ast.FieldList)
	if !ok {
		return errorz.New("new is not *ast.FieldList")
	}
	p.TypeParams = n
	return nil
}

func replaceFuncType_Params(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.FuncType)
	if !ok {
		return errorz.New("parent is not *ast.FuncType")
	}
	n, ok := new.(*ast.FieldList)
	if !ok {
		return errorz.New("new is not *ast.FieldList")
	}
	p.Params = n
	return nil
}

func replaceFuncType_Results(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.FuncType)
	if !ok {
		return errorz.New("parent is not *ast.FuncType")
	}
	n, ok := new.(*ast.FieldList)
	if !ok {
		return errorz.New("new is not *ast.FieldList")
	}
	p.Results = n
	return nil
}

func replaceGenDecl_Doc(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.GenDecl)
	if !ok {
		return errorz.New("parent is not *ast.GenDecl")
	}
	n, ok := new.(*ast.CommentGroup)
	if !ok {
		return errorz.New("new is not *ast.CommentGroup")
	}
	p.Doc = n
	return nil
}

func replaceGenDecl_Specs(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.GenDecl)
	if !ok {
		return errorz.New("parent is not *ast.GenDecl")
	}
	n, ok := new.(ast.Spec)
	if !ok {
		return errorz.New("new is not ast.Spec")
	}
	switch {
	case idx < 0 || idx > len(p.Specs):
		return errorz.Newf("index out of range (idx=%s, len=%s)", idx, len(p.Specs))
	case idx == len(p.Specs):
		p.Specs = append(p.Specs, n)
	default:
		p.Specs[idx] = n
	}
	return nil
}

func replaceGoStmt_Call(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.GoStmt)
	if !ok {
		return errorz.New("parent is not *ast.GoStmt")
	}
	n, ok := new.(*ast.CallExpr)
	if !ok {
		return errorz.New("new is not *ast.CallExpr")
	}
	p.Call = n
	return nil
}

func replaceIfStmt_Init(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.IfStmt)
	if !ok {
		return errorz.New("parent is not *ast.IfStmt")
	}
	n, ok := new.(ast.Stmt)
	if !ok {
		return errorz.New("new is not ast.Stmt")
	}
	p.Init = n
	return nil
}

func replaceIfStmt_Cond(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.IfStmt)
	if !ok {
		return errorz.New("parent is not *ast.IfStmt")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Cond = n
	return nil
}

func replaceIfStmt_Body(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.IfStmt)
	if !ok {
		return errorz.New("parent is not *ast.IfStmt")
	}
	n, ok := new.(*ast.BlockStmt)
	if !ok {
		return errorz.New("new is not *ast.BlockStmt")
	}
	p.Body = n
	return nil
}

func replaceIfStmt_Else(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.IfStmt)
	if !ok {
		return errorz.New("parent is not *ast.IfStmt")
	}
	n, ok := new.(ast.Stmt)
	if !ok {
		return errorz.New("new is not ast.Stmt")
	}
	p.Else = n
	return nil
}

func replaceImportSpec_Doc(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.ImportSpec)
	if !ok {
		return errorz.New("parent is not *ast.ImportSpec")
	}
	n, ok := new.(*ast.CommentGroup)
	if !ok {
		return errorz.New("new is not *ast.CommentGroup")
	}
	p.Doc = n
	return nil
}

func replaceImportSpec_Name(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.ImportSpec)
	if !ok {
		return errorz.New("parent is not *ast.ImportSpec")
	}
	n, ok := new.(*ast.Ident)
	if !ok {
		return errorz.New("new is not *ast.Ident")
	}
	p.Name = n
	return nil
}

func replaceImportSpec_Path(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.ImportSpec)
	if !ok {
		return errorz.New("parent is not *ast.ImportSpec")
	}
	n, ok := new.(*ast.BasicLit)
	if !ok {
		return errorz.New("new is not *ast.BasicLit")
	}
	p.Path = n
	return nil
}

func replaceImportSpec_Comment(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.ImportSpec)
	if !ok {
		return errorz.New("parent is not *ast.ImportSpec")
	}
	n, ok := new.(*ast.CommentGroup)
	if !ok {
		return errorz.New("new is not *ast.CommentGroup")
	}
	p.Comment = n
	return nil
}

func replaceIncDecStmt_X(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.IncDecStmt)
	if !ok {
		return errorz.New("parent is not *ast.IncDecStmt")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.X = n
	return nil
}

func replaceIndexExpr_X(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.IndexExpr)
	if !ok {
		return errorz.New("parent is not *ast.IndexExpr")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.X = n
	return nil
}

func replaceIndexExpr_Index(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.IndexExpr)
	if !ok {
		return errorz.New("parent is not *ast.IndexExpr")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Index = n
	return nil
}

func replaceIndexListExpr_X(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.IndexListExpr)
	if !ok {
		return errorz.New("parent is not *ast.IndexListExpr")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.X = n
	return nil
}

func replaceIndexListExpr_Indices(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.IndexListExpr)
	if !ok {
		return errorz.New("parent is not *ast.IndexListExpr")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	switch {
	case idx < 0 || idx > len(p.Indices):
		return errorz.Newf("index out of range (idx=%s, len=%s)", idx, len(p.Indices))
	case idx == len(p.Indices):
		p.Indices = append(p.Indices, n)
	default:
		p.Indices[idx] = n
	}
	return nil
}

func replaceInterfaceType_Methods(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.InterfaceType)
	if !ok {
		return errorz.New("parent is not *ast.InterfaceType")
	}
	n, ok := new.(*ast.FieldList)
	if !ok {
		return errorz.New("new is not *ast.FieldList")
	}
	p.Methods = n
	return nil
}

func replaceKeyValueExpr_Key(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.KeyValueExpr)
	if !ok {
		return errorz.New("parent is not *ast.KeyValueExpr")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Key = n
	return nil
}

func replaceKeyValueExpr_Value(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.KeyValueExpr)
	if !ok {
		return errorz.New("parent is not *ast.KeyValueExpr")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Value = n
	return nil
}

func replaceLabeledStmt_Label(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.LabeledStmt)
	if !ok {
		return errorz.New("parent is not *ast.LabeledStmt")
	}
	n, ok := new.(*ast.Ident)
	if !ok {
		return errorz.New("new is not *ast.Ident")
	}
	p.Label = n
	return nil
}

func replaceLabeledStmt_Stmt(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.LabeledStmt)
	if !ok {
		return errorz.New("parent is not *ast.LabeledStmt")
	}
	n, ok := new.(ast.Stmt)
	if !ok {
		return errorz.New("new is not ast.Stmt")
	}
	p.Stmt = n
	return nil
}

func replaceMapType_Key(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.MapType)
	if !ok {
		return errorz.New("parent is not *ast.MapType")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Key = n
	return nil
}

func replaceMapType_Value(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.MapType)
	if !ok {
		return errorz.New("parent is not *ast.MapType")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Value = n
	return nil
}

func replaceParenExpr_X(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.ParenExpr)
	if !ok {
		return errorz.New("parent is not *ast.ParenExpr")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.X = n
	return nil
}

func replaceRangeStmt_Key(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.RangeStmt)
	if !ok {
		return errorz.New("parent is not *ast.RangeStmt")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Key = n
	return nil
}

func replaceRangeStmt_Value(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.RangeStmt)
	if !ok {
		return errorz.New("parent is not *ast.RangeStmt")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Value = n
	return nil
}

func replaceRangeStmt_X(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.RangeStmt)
	if !ok {
		return errorz.New("parent is not *ast.RangeStmt")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.X = n
	return nil
}

func replaceRangeStmt_Body(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.RangeStmt)
	if !ok {
		return errorz.New("parent is not *ast.RangeStmt")
	}
	n, ok := new.(*ast.BlockStmt)
	if !ok {
		return errorz.New("new is not *ast.BlockStmt")
	}
	p.Body = n
	return nil
}

func replaceReturnStmt_Results(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.ReturnStmt)
	if !ok {
		return errorz.New("parent is not *ast.ReturnStmt")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	switch {
	case idx < 0 || idx > len(p.Results):
		return errorz.Newf("index out of range (idx=%s, len=%s)", idx, len(p.Results))
	case idx == len(p.Results):
		p.Results = append(p.Results, n)
	default:
		p.Results[idx] = n
	}
	return nil
}

func replaceSelectStmt_Body(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.SelectStmt)
	if !ok {
		return errorz.New("parent is not *ast.SelectStmt")
	}
	n, ok := new.(*ast.BlockStmt)
	if !ok {
		return errorz.New("new is not *ast.BlockStmt")
	}
	p.Body = n
	return nil
}

func replaceSelectorExpr_X(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.SelectorExpr)
	if !ok {
		return errorz.New("parent is not *ast.SelectorExpr")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.X = n
	return nil
}

func replaceSelectorExpr_Sel(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.SelectorExpr)
	if !ok {
		return errorz.New("parent is not *ast.SelectorExpr")
	}
	n, ok := new.(*ast.Ident)
	if !ok {
		return errorz.New("new is not *ast.Ident")
	}
	p.Sel = n
	return nil
}

func replaceSendStmt_Chan(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.SendStmt)
	if !ok {
		return errorz.New("parent is not *ast.SendStmt")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Chan = n
	return nil
}

func replaceSendStmt_Value(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.SendStmt)
	if !ok {
		return errorz.New("parent is not *ast.SendStmt")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Value = n
	return nil
}

func replaceSliceExpr_X(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.SliceExpr)
	if !ok {
		return errorz.New("parent is not *ast.SliceExpr")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.X = n
	return nil
}

func replaceSliceExpr_Low(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.SliceExpr)
	if !ok {
		return errorz.New("parent is not *ast.SliceExpr")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Low = n
	return nil
}

func replaceSliceExpr_High(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.SliceExpr)
	if !ok {
		return errorz.New("parent is not *ast.SliceExpr")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.High = n
	return nil
}

func replaceSliceExpr_Max(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.SliceExpr)
	if !ok {
		return errorz.New("parent is not *ast.SliceExpr")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Max = n
	return nil
}

func replaceStarExpr_X(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.StarExpr)
	if !ok {
		return errorz.New("parent is not *ast.StarExpr")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.X = n
	return nil
}

func replaceStructType_Fields(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.StructType)
	if !ok {
		return errorz.New("parent is not *ast.StructType")
	}
	n, ok := new.(*ast.FieldList)
	if !ok {
		return errorz.New("new is not *ast.FieldList")
	}
	p.Fields = n
	return nil
}

func replaceSwitchStmt_Init(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.SwitchStmt)
	if !ok {
		return errorz.New("parent is not *ast.SwitchStmt")
	}
	n, ok := new.(ast.Stmt)
	if !ok {
		return errorz.New("new is not ast.Stmt")
	}
	p.Init = n
	return nil
}

func replaceSwitchStmt_Tag(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.SwitchStmt)
	if !ok {
		return errorz.New("parent is not *ast.SwitchStmt")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Tag = n
	return nil
}

func replaceSwitchStmt_Body(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.SwitchStmt)
	if !ok {
		return errorz.New("parent is not *ast.SwitchStmt")
	}
	n, ok := new.(*ast.BlockStmt)
	if !ok {
		return errorz.New("new is not *ast.BlockStmt")
	}
	p.Body = n
	return nil
}

func replaceTypeAssertExpr_X(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.TypeAssertExpr)
	if !ok {
		return errorz.New("parent is not *ast.TypeAssertExpr")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.X = n
	return nil
}

func replaceTypeAssertExpr_Type(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.TypeAssertExpr)
	if !ok {
		return errorz.New("parent is not *ast.TypeAssertExpr")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Type = n
	return nil
}

func replaceTypeSpec_Doc(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.TypeSpec)
	if !ok {
		return errorz.New("parent is not *ast.TypeSpec")
	}
	n, ok := new.(*ast.CommentGroup)
	if !ok {
		return errorz.New("new is not *ast.CommentGroup")
	}
	p.Doc = n
	return nil
}

func replaceTypeSpec_Name(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.TypeSpec)
	if !ok {
		return errorz.New("parent is not *ast.TypeSpec")
	}
	n, ok := new.(*ast.Ident)
	if !ok {
		return errorz.New("new is not *ast.Ident")
	}
	p.Name = n
	return nil
}

func replaceTypeSpec_TypeParams(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.TypeSpec)
	if !ok {
		return errorz.New("parent is not *ast.TypeSpec")
	}
	n, ok := new.(*ast.FieldList)
	if !ok {
		return errorz.New("new is not *ast.FieldList")
	}
	p.TypeParams = n
	return nil
}

func replaceTypeSpec_Type(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.TypeSpec)
	if !ok {
		return errorz.New("parent is not *ast.TypeSpec")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Type = n
	return nil
}

func replaceTypeSpec_Comment(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.TypeSpec)
	if !ok {
		return errorz.New("parent is not *ast.TypeSpec")
	}
	n, ok := new.(*ast.CommentGroup)
	if !ok {
		return errorz.New("new is not *ast.CommentGroup")
	}
	p.Comment = n
	return nil
}

func replaceTypeSwitchStmt_Init(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.TypeSwitchStmt)
	if !ok {
		return errorz.New("parent is not *ast.TypeSwitchStmt")
	}
	n, ok := new.(ast.Stmt)
	if !ok {
		return errorz.New("new is not ast.Stmt")
	}
	p.Init = n
	return nil
}

func replaceTypeSwitchStmt_Assign(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.TypeSwitchStmt)
	if !ok {
		return errorz.New("parent is not *ast.TypeSwitchStmt")
	}
	n, ok := new.(ast.Stmt)
	if !ok {
		return errorz.New("new is not ast.Stmt")
	}
	p.Assign = n
	return nil
}

func replaceTypeSwitchStmt_Body(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.TypeSwitchStmt)
	if !ok {
		return errorz.New("parent is not *ast.TypeSwitchStmt")
	}
	n, ok := new.(*ast.BlockStmt)
	if !ok {
		return errorz.New("new is not *ast.BlockStmt")
	}
	p.Body = n
	return nil
}

func replaceUnaryExpr_X(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.UnaryExpr)
	if !ok {
		return errorz.New("parent is not *ast.UnaryExpr")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.X = n
	return nil
}

func replaceValueSpec_Doc(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.ValueSpec)
	if !ok {
		return errorz.New("parent is not *ast.ValueSpec")
	}
	n, ok := new.(*ast.CommentGroup)
	if !ok {
		return errorz.New("new is not *ast.CommentGroup")
	}
	p.Doc = n
	return nil
}

func replaceValueSpec_Names(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.ValueSpec)
	if !ok {
		return errorz.New("parent is not *ast.ValueSpec")
	}
	n, ok := new.(*ast.Ident)
	if !ok {
		return errorz.New("new is not *ast.Ident")
	}
	switch {
	case idx < 0 || idx > len(p.Names):
		return errorz.Newf("index out of range (idx=%s, len=%s)", idx, len(p.Names))
	case idx == len(p.Names):
		p.Names = append(p.Names, n)
	default:
		p.Names[idx] = n
	}
	return nil
}

func replaceValueSpec_Type(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.ValueSpec)
	if !ok {
		return errorz.New("parent is not *ast.ValueSpec")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	p.Type = n
	return nil
}

func replaceValueSpec_Values(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.ValueSpec)
	if !ok {
		return errorz.New("parent is not *ast.ValueSpec")
	}
	n, ok := new.(ast.Expr)
	if !ok {
		return errorz.New("new is not ast.Expr")
	}
	switch {
	case idx < 0 || idx > len(p.Values):
		return errorz.Newf("index out of range (idx=%s, len=%s)", idx, len(p.Values))
	case idx == len(p.Values):
		p.Values = append(p.Values, n)
	default:
		p.Values[idx] = n
	}
	return nil
}

func replaceValueSpec_Comment(parent ast.Node, idx int, new ast.Node) error {
	p, ok := parent.(*ast.ValueSpec)
	if !ok {
		return errorz.New("parent is not *ast.ValueSpec")
	}
	n, ok := new.(*ast.CommentGroup)
	if !ok {
		return errorz.New("new is not *ast.CommentGroup")
	}
	p.Comment = n
	return nil
}
